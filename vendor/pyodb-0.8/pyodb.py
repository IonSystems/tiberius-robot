# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.33
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

import _pyodb
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


BUF_SIZE = _pyodb.BUF_SIZE
MSG_BUF = _pyodb.MSG_BUF
STATE_LEN = _pyodb.STATE_LEN
FETCH_BLOCKS = _pyodb.FETCH_BLOCKS
MAX_COLUMN_WIDTH = _pyodb.MAX_COLUMN_WIDTH
class cinfo_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cinfo_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cinfo_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dsn"] = _pyodb.cinfo_t_dsn_set
    __swig_getmethods__["dsn"] = _pyodb.cinfo_t_dsn_get
    if _newclass:dsn = _swig_property(_pyodb.cinfo_t_dsn_get, _pyodb.cinfo_t_dsn_set)
    __swig_setmethods__["henv"] = _pyodb.cinfo_t_henv_set
    __swig_getmethods__["henv"] = _pyodb.cinfo_t_henv_get
    if _newclass:henv = _swig_property(_pyodb.cinfo_t_henv_get, _pyodb.cinfo_t_henv_set)
    __swig_setmethods__["hdbc"] = _pyodb.cinfo_t_hdbc_set
    __swig_getmethods__["hdbc"] = _pyodb.cinfo_t_hdbc_get
    if _newclass:hdbc = _swig_property(_pyodb.cinfo_t_hdbc_get, _pyodb.cinfo_t_hdbc_set)
    __swig_setmethods__["hstmt"] = _pyodb.cinfo_t_hstmt_set
    __swig_getmethods__["hstmt"] = _pyodb.cinfo_t_hstmt_get
    if _newclass:hstmt = _swig_property(_pyodb.cinfo_t_hstmt_get, _pyodb.cinfo_t_hstmt_set)
    __swig_setmethods__["autocommit"] = _pyodb.cinfo_t_autocommit_set
    __swig_getmethods__["autocommit"] = _pyodb.cinfo_t_autocommit_get
    if _newclass:autocommit = _swig_property(_pyodb.cinfo_t_autocommit_get, _pyodb.cinfo_t_autocommit_set)
    __swig_setmethods__["next"] = _pyodb.cinfo_t_next_set
    __swig_getmethods__["next"] = _pyodb.cinfo_t_next_get
    if _newclass:next = _swig_property(_pyodb.cinfo_t_next_get, _pyodb.cinfo_t_next_set)
    __swig_setmethods__["prev"] = _pyodb.cinfo_t_prev_set
    __swig_getmethods__["prev"] = _pyodb.cinfo_t_prev_get
    if _newclass:prev = _swig_property(_pyodb.cinfo_t_prev_get, _pyodb.cinfo_t_prev_set)
    def __init__(self, *args): 
        this = _pyodb.new_cinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyodb.delete_cinfo_t
    __del__ = lambda self : None;
cinfo_t_swigregister = _pyodb.cinfo_t_swigregister
cinfo_t_swigregister(cinfo_t)

class sqlstate_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sqlstate_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sqlstate_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sqlstate"] = _pyodb.sqlstate_t_sqlstate_set
    __swig_getmethods__["sqlstate"] = _pyodb.sqlstate_t_sqlstate_get
    if _newclass:sqlstate = _swig_property(_pyodb.sqlstate_t_sqlstate_get, _pyodb.sqlstate_t_sqlstate_set)
    __swig_setmethods__["message"] = _pyodb.sqlstate_t_message_set
    __swig_getmethods__["message"] = _pyodb.sqlstate_t_message_get
    if _newclass:message = _swig_property(_pyodb.sqlstate_t_message_get, _pyodb.sqlstate_t_message_set)
    def __init__(self, *args): 
        this = _pyodb.new_sqlstate_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyodb.delete_sqlstate_t
    __del__ = lambda self : None;
sqlstate_t_swigregister = _pyodb.sqlstate_t_swigregister
sqlstate_t_swigregister(sqlstate_t)
cvar = _pyodb.cvar

getstate = _pyodb.getstate
getmsg = _pyodb.getmsg
get_conninfo = _pyodb.get_conninfo
_connect = _pyodb._connect
_disconnect = _pyodb._disconnect
_execute = _pyodb._execute
get_data = _pyodb.get_data
get_col_data = _pyodb.get_col_data
_fetch = _pyodb._fetch
_begin = _pyodb._begin
_commit = _pyodb._commit
_rollback = _pyodb._rollback
import exceptions, types, string
class ConnectError(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class ExecuteError(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class FetchError(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class TransactionError(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class NotConnectedError(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class Connect:
    dsn = "default"
    uid = ""
    pwd = ""
    conn = ""
    connected = 0

    def __init__(self, dsn="default", uid="", pwd="", conn=""):
        self.dsn = dsn
        self.uid = uid
        self.pwd = pwd
        self.conn = conn
        try:
            _connect(self.dsn, self.uid, self.pwd, self.conn)
        except Exception, e:
            raise ConnectError, e
        self.connected = 1

    def __del__(self, dsn="default"):
        if self.connected:
            _disconnect(self.dsn)
            self.connected = 0

    def execute(self, sql):
        if not self.connected:
            raise NotConnectedError, "Data source '" + self.dsn + \
                "' is not connected"
            return 0;

        try:
            ret = _execute(self.dsn, sql);
        except Exception, e:
            raise ExecuteError, e
        return ret

    def fetch(self, nrows=0):
        if not self.connected:
            raise NotConnectedError, "Data source '" + self.dsn + \
                "' is not connected"
            return 0;

        try:
            rows = _fetch(self.dsn, nrows)
        except Exception, e:
            raise FetchError, e
        return rows

    def begin(self):
        if not self.connected:
            raise NotConnectedError, "Data source '" + self.dsn + \
                "' is not connected"

        try:
            _begin(self.dsn)
        except Exception, e:
            raise TransactionError, e

    def commit(self):
        if not self.connected:
            raise NotConnectedError, "Data source '" + self.dsn + \
                "' is not connected"

        try:
            _commit(self.dsn)
        except Exception, e:
            raise TransactionError, e

    def rollback(self):
        if not self.connected:
            raise NotConnectedError, "Data source '" + self.dsn + \
                "' is not connected"

        try:
            _rollback(self.dsn)
        except Exception, e:
            raise TransactionError, e

    def disconnect(self):
        if self.connected:
            _disconnect(self.dsn)
            self.connected = 0




